/*table  foo(key : int z ,int p value : int v) with merge min z 
table  xyz(key : int m ,int n value : int vo) with merge min m
table  abc_table(key: int a, int b  value: int zp, int vp) with merge min x
rule abc_table(p, v1, z, v) :- foo(z, p, v),  xyz(p, z, v1); v1==v,  int a = 5;



table packet(@CTR key : int dst_mac value :) with merge min dst_mac
table mac_table(key : int dst_mac value: int port) with merge min port
table learn_mac(key : int dst_mac value: int learn) with merge min port
table learn_mac2(key : int dst_mac value: int learn) with merge min port

rule mac_table(dst_mac, port_act)  with merge min cost3 :- packet(@CTR dst_mac); 1==1, int port_act = ingress_port;
rule learn_mac(dst_mac, learn)  with merge min cost3 :- mac_table(dst_mac, port_act); port_act!=255, int learn = 1; 
rule learn_mac2(dst_mac, learn)  with merge min cost3 :- mac_table(dst_mac, port_act); port_act!=255, int learn = 1; 



table  link(@SELF key :int dest  value : int cost, int port) with merge min c
table  hops(@next key : int dest  value : int cost, int hop, int port) with merge min cost

rule hops(@SELF dest, cost, dest, port)  :- link(@SELF dest, cost, port); cost==cost, int cost1=cost;
rule hops(@SELF dest, cost3, next, port_main) with merge min cost3 :- hops(@next dest, cost, hop, port), link(@SELF next, cost2, port_main); cost2==cost2, int cost3= cost2+cost;


memop incr (int stored_ct, int incr_by) {
  return stored_ct + incr_by;
}


table packet(@CTR key : int src, int dst, int bytes value :) with merge min bytes
table netflow_cache(key : int src, int dst value : int byte, int packets)  with merge freq byte, count

rule netflow_cache(src, dst, byte) with merge freq byte,bytes :- packet(@CTR src, dst, bytes); 1 ==1, int a = 6;



exit event response_continue (int src_ip, int dst_ip);
entry event response_packet (int server_ip, int client_ip);

handle response_packet(int server_ip, int client_ip) {
  int <<16>> idx = hash<<16>>(server_ip, client_ip);
  if (Array.get(firewall_mem, idx) == 1) {
    generate response_continue(client_ip, server_ip); // Or maybe the other way around?
  }
}


table localhost(@CTR key : int client_ip, int server_ip value : ) with merge min bytes 
table firewall(key : int client_ip, int server_ip value : int mem) with merge min bytes 

rule firewall(client_ip, server_ip, mem) with merge min cost3 :-
  localhost(@CTR client_ip, server_ip); 1==1, int mem= 1;
*/

memop min_arg(int x, int y) {
   
    if (x < y)  {
        return x;
    }
    else{

        return y;
    }
}

memop test_min(int x, int y) {
     
    if (x < y)  {
        return 1;
    }
    else{

        return 0;
    }
}
const int<<32>> SELF = 0;

const int<<32>> SEED = 2048;

entry control event rule_hops_1(int<<32>> SELF,int<<32>> dest) ;

entry control event rule_hops_2(int<<32>> next,int<<32>> dest,int<<32>> cost,int<<32>> hop,int<<32>> port) ;

global Array.t<<32>> link_cost = Array.create(1024);


global Array.t<<32>> link_port = Array.create(1024);


entry control event event_link(int<<32>> SELF,int<<32>> dest,int<<32>> cost,int<<32>> port) ;

handle event_link(int<<32>> SELF,int<<32>> dest,int<<32>> cost,int<<32>> port) {
int<<16>> idx_3 = hash<<16>>(SEED,SELF,dest);
Array.set(link_cost,idx_3,port);
Array.set(link_port,idx_3,cost);
generate rule_hops_1(SELF,dest);
}

global Array.t<<32>> hops_cost = Array.create(1024);


global Array.t<<32>> hops_hop = Array.create(1024);


global Array.t<<32>> hops_port = Array.create(1024);


entry control event event_hops(int<<32>> next,int<<32>> dest,int<<32>> cost,int<<32>> hop,int<<32>> port) ;

handle event_hops(int<<32>> next,int<<32>> dest,int<<32>> cost,int<<32>> hop,int<<32>> port) {
    int<<16>> idx_6 = hash<<16>>(SEED,SELF,next);
    int<<32>> cost2 = Array.get(link_cost,idx_6);
    int<<32>> port_main = Array.get(link_port,idx_6);
    int<<32>> cost3 = cost2+cost;
    int<<16>> idx_7 = hash<<16>>(SEED,SELF,dest);
    int min_success = Array.update(hops_cost, idx_7,
        test_min, cost3,
        min_arg, cost3);
    if (min_success == 1)
    {
          Array.set(hops_hop,idx_7,next);
                    Array.set(hops_port,idx_7,port_main);

          generate_ports ({1}, event_hops(SELF, dest, next, cost3, port_main));
    }}

handle rule_hops_1(int<<32>> SELF,int<<32>> dest) {
int<<16>> idx_4 = hash<<16>>(2048,SELF,dest);
int<<32>> cost = Array.get(link_cost,idx_4);
int<<32>> port = Array.get(link_port,idx_4);
int<<32>> cost1 = cost;
int<<16>> idx_5 = hash<<16>>(2048,SELF,dest);
Array.set(hops_cost,idx_5,cost);
Array.set(hops_hop,idx_5,dest);
Array.set(hops_port,idx_5,port);
generate_ports ({1}, event_hops(SELF, dest, dest, cost, port));

} 



handle rule_hops_2(int<<32>> next,int<<32>> dest,int<<32>> cost,int<<32>> hop, int<<32>> port) {
    int<<16>> idx_6 = hash<<16>>(SEED,SELF,next);
    int<<32>> cost2 = Array.get(link_cost,idx_6);
    int<<32>> port_main = Array.get(link_port,idx_6);
    int<<32>> cost3 = cost2+cost;
    int<<16>> idx_7 = hash<<16>>(SEED,SELF,dest);
    int min_success = Array.update(hops_cost, idx_7,
        test_min, cost3,
        min_arg, cost3);
    if (min_success == 1)
    {
          Array.set(hops_hop,idx_7,next);
                    Array.set(hops_port,idx_7,port_main);

          generate_ports ({1}, event_hops(SELF, dest, next, cost3, port_main));
    }

}

global Array.t<<32>> nid_port = Array.create(1024);
exit event packetout(int outport);

entry event packetin(int dst);

handle packetin(int dst) {

    // check if a path exists.
    int<<16>> idx = hash<<16>>(SEED,SELF,dst);
    int next_hop = Array.get(hops_hop, idx);
    if ((next_hop != 255)) {
            int outport = Array.get(nid_port, next_hop);
            generate packetout(outport);
    }

}
